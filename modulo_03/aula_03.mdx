# Funções e Modificadores em Solidity

Nesta aula, vamos explorar o uso de funções e modificadores em Solidity, que são fundamentais para a organização e controle de acesso em contratos inteligentes.

## Declaração de Funções

As funções são blocos de código que executam ações específicas e podem modificar o estado do contrato. Elas são a principal forma de interação com o contrato.

- **Funções Públicas:** Podem ser chamadas por qualquer pessoa. Devem ser usadas com cautela para evitar acessos indesejados.

  - **Exemplo:**
    ```solidity
    function depositar(uint256 valor) public {
        saldo += valor;
    }
    ```

- **Funções Privadas:** Só podem ser chamadas de dentro do contrato. São úteis para lógica interna que não deve ser exposta.

  - **Exemplo:**
    ```solidity
    function calcularTaxa(uint256 valor) private pure returns (uint256) {
        return valor / 100;
    }
    ```

- **Funções de Visualização (View):** Não alteram o estado do contrato e podem ser chamadas sem custo de gas.

  - **Exemplo:**
    ```solidity
    function obterSaldo() public view returns (uint256) {
        return saldo;
    }
    ```

- **Funções Puras (Pure):** Não acessam nem modificam o estado do contrato.
  - **Exemplo:**
    ```solidity
    function somar(uint256 a, uint256 b) public pure returns (uint256) {
        return a + b;
    }
    ```

## Modificadores de Função

Modificadores são usados para alterar o comportamento de funções, adicionando condições ou restrições.

- **Modificadores de Acesso:** Restringem quem pode chamar uma função.

  - **Exemplo:**

    ```solidity
    modifier somenteProprietario() {
        require(msg.sender == proprietario, "Acesso negado");
        _;
    }

    function retirar(uint256 valor) public somenteProprietario {
        saldo -= valor;
    }
    ```

- **Modificadores de Validação:** Verificam condições antes de executar a função.

  - **Exemplo:**

    ```solidity
    modifier validarValor(uint256 valor) {
        require(valor > 0, "Valor deve ser maior que zero");
        _;
    }

    function depositar(uint256 valor) public validarValor(valor) {
        saldo += valor;
    }
    ```

## Uso de `require` e `assert`

- **`require`:** Verifica condições e reverte a transação se a condição não for atendida. É usado para validar entradas e garantir que as pré-condições sejam satisfeitas.

  - **Exemplo:**
    ```solidity
    function transferir(address para, uint256 valor) public {
        require(saldo >= valor, "Saldo insuficiente");
        saldo -= valor;
        // Lógica de transferência
    }
    ```

- **`assert`:** Verifica condições internas e reverte a transação se a condição não for atendida. É usado para verificar invariantes e garantir que o contrato esteja em um estado consistente.
  - **Exemplo:**
    ```solidity
    function atualizarSaldo(uint256 novoSaldo) internal {
        saldo = novoSaldo;
        assert(saldo >= 0);
    }
    ```

## Boas Práticas de Uso

Para garantir que o uso de funções e modificadores seja eficiente e seguro, siga estas boas práticas:

- **Validação de Entradas:** Sempre valide as entradas do usuário para evitar erros e vulnerabilidades.
- **Uso de Modificadores:** Utilize modificadores para implementar lógica de controle de acesso e evitar duplicação de código.
- **Documentação de Funções:** Documente todas as funções e modificadores para facilitar a manutenção e auditoria do contrato.
- **Reutilização de Código:** Utilize funções e modificadores para evitar duplicação de lógica e melhorar a legibilidade do código.
